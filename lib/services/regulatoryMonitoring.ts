// Enhanced Regulatory Monitoring Service - Core monitoring engine for real-time regulatory intelligence
// Integrates with Korean Government APIs and provides comprehensive change detection and alerting

import { Idea } from '@/lib/types';
import { 
  koreanGovAPIs, 
  RegulatoryDocument, 
  RegulatoryAlert, 
  GovDataSource,
  AlertType 
} from './koreanGovAPIs';
import { emailNotificationService } from './emailNotificationService';
import crypto from 'crypto';

export interface RegulatoryUpdate {
  id: string;
  sourceUrl: string;
  title: string;
  summary: string;
  publishedDate: Date;
  effectiveDate?: Date;
  ministry: string;
  category: 'law' | 'decree' | 'regulation' | 'guideline' | 'announcement';
  industries: string[];
  complianceRequired: boolean;
  businessImpact: 'high' | 'medium' | 'low';
  keyChanges: string[];
  affectedBusinessTypes: string[];
  actionItems: string[];
  deadline?: Date;
  penalties?: string;
  opportunities?: string[];
  risks?: string[];
  relatedRegulations?: string[];
  fullText?: string;
  lastChecked: Date;
  changeDetected: boolean;
  previousVersion?: string;
}

export interface MonitoringConfiguration {
  checkIntervalMinutes: number;
  enableRealTimeAlerts: boolean;
  enableEmailNotifications: boolean;
  enableSlackIntegration: boolean;
  industryFilters: string[];
  severityFilters: ('critical' | 'high' | 'medium' | 'low')[];
  businessTypeFilters: string[];
  autoTranslation: boolean;
  retentionDays: number;
}

export interface MonitoringStats {
  totalDocumentsProcessed: number;
  alertsGenerated24h: number;
  criticalAlerts24h: number;
  sourcesMonitored: number;
  lastSuccessfulCheck: Date;
  averageProcessingTime: number;
  errorRate: number;
  uptime: number;
}

export interface ChangeDetectionResult {
  documentId: string;
  changeType: 'new' | 'modified' | 'deleted';
  changedSections: ChangedSection[];
  severity: 'critical' | 'high' | 'medium' | 'low';
  confidence: number; // 0-100%
  automatedAnalysis: string;
  requiresHumanReview: boolean;
}

export interface ChangedSection {
  sectionName: string;
  previousContent: string;
  newContent: string;
  changeType: 'addition' | 'deletion' | 'modification';
  impactAssessment: string;
}

export interface ComplianceDeadline {
  documentId: string;
  title: string;
  deadline: Date;
  daysRemaining: number;
  severity: 'critical' | 'high' | 'medium' | 'low';
  affectedIndustries: string[];
  requirements: string[];
  penalties: string[];
  actionItems: string[];
}

export interface IndustryImpactAnalysis {
  industry: string;
  impactScore: number; // 0-100
  affectedDocuments: string[];
  keyRegulations: RegulatoryDocument[];
  riskLevel: 'very_high' | 'high' | 'medium' | 'low' | 'very_low';
  opportunityAreas: string[];
  complianceGaps: string[];
  recommendations: string[];
}

// ===== ENHANCED REGULATORY MONITORING SERVICE =====

export class EnhancedRegulatoryMonitoringService {
  private config: MonitoringConfiguration = {
    checkIntervalMinutes: 30,
    enableRealTimeAlerts: true,
    enableEmailNotifications: true,
    enableSlackIntegration: false,
    industryFilters: [],
    severityFilters: ['critical', 'high'],
    businessTypeFilters: [],
    autoTranslation: false,
    retentionDays: 365
  };

  private monitoringStats: MonitoringStats = {
    totalDocumentsProcessed: 0,
    alertsGenerated24h: 0,
    criticalAlerts24h: 0,
    sourcesMonitored: 0,
    lastSuccessfulCheck: new Date(),
    averageProcessingTime: 0,
    errorRate: 0,
    uptime: 100
  };

  private isMonitoring = false;
  private monitoringInterval: NodeJS.Timeout | null = null;
  private documentHistory = new Map<string, RegulatoryDocument[]>();
  private alertHistory = new Map<string, RegulatoryAlert[]>();
  private processingQueue: string[] = [];
  private errorLog: Array<{ timestamp: Date; error: string; source: string }> = [];

  // ===== MAIN MONITORING LOOP =====

  async startMonitoring(): Promise<void> {
    if (this.isMonitoring) {
      console.log('‚ö†Ô∏è Monitoring already active');
      return;
    }

    console.log('üöÄ Starting enhanced regulatory monitoring system...');
    this.isMonitoring = true;

    // Initial full scan
    await this.performFullScan();

    // Set up periodic monitoring
    this.monitoringInterval = setInterval(
      () => this.performIncrementalScan(),
      this.config.checkIntervalMinutes * 60 * 1000
    );

    console.log(`‚úÖ Monitoring active - checking every ${this.config.checkIntervalMinutes} minutes`);
  }

  async stopMonitoring(): Promise<void> {
    console.log('üõë Stopping regulatory monitoring system...');
    this.isMonitoring = false;

    if (this.monitoringInterval) {
      clearInterval(this.monitoringInterval);
      this.monitoringInterval = null;
    }

    console.log('‚úÖ Monitoring stopped');
  }

  private async performFullScan(): Promise<void> {
    const startTime = Date.now();
    console.log('üîç Performing full regulatory scan...');

    try {
      // Fetch from all Korean government sources
      const documents = await koreanGovAPIs.fetchAllSources();
      console.log(`üìÑ Retrieved ${documents.length} documents from ${await this.getActiveSourceCount()} sources`);

      // Process documents and detect changes
      const changeResults = await this.performChangeDetection(documents);
      console.log(`üîÑ Detected ${changeResults.length} changes`);

      // Generate alerts for significant changes
      const alerts = await this.generateIntelligentAlerts(documents, changeResults);
      console.log(`üö® Generated ${alerts.length} alerts`);

      // Send notifications for critical alerts
      await this.processAlertNotifications(alerts);

      // Update statistics
      this.updateMonitoringStats(documents, alerts, Date.now() - startTime);

      // Store results for future comparison
      await this.storeDocumentHistory(documents);

      console.log('‚úÖ Full scan completed successfully');

    } catch (error) {
      console.error('‚ùå Full scan failed:', error);
      this.logError('full_scan', error as string);
    }
  }

  private async performIncrementalScan(): Promise<void> {
    if (!this.isMonitoring) return;

    const startTime = Date.now();
    console.log('üîç Performing incremental regulatory scan...');

    try {
      // Get recent changes only (last 2 hours)
      const recentDocs = await koreanGovAPIs.getRecentChanges(0.083); // 2 hours in days
      
      if (recentDocs.length === 0) {
        console.log('‚ÑπÔ∏è No new changes detected');
        return;
      }

      console.log(`üìÑ Processing ${recentDocs.length} recent documents`);

      // Analyze changes with higher precision
      const changeResults = await this.performAdvancedChangeDetection(recentDocs);
      
      // Generate real-time alerts
      const alerts = await this.generateRealTimeAlerts(recentDocs, changeResults);
      
      if (alerts.length > 0) {
        console.log(`üö® Generated ${alerts.length} real-time alerts`);
        await this.processUrgentAlerts(alerts);
      }

      // Update incremental statistics
      this.updateIncrementalStats(recentDocs, alerts, Date.now() - startTime);

    } catch (error) {
      console.error('‚ùå Incremental scan failed:', error);
      this.logError('incremental_scan', error as string);
    }
  }

  // ===== ADVANCED CHANGE DETECTION ALGORITHMS =====

  private async performChangeDetection(documents: RegulatoryDocument[]): Promise<ChangeDetectionResult[]> {
    const results: ChangeDetectionResult[] = [];

    for (const doc of documents) {
      try {
        const changeResult = await this.analyzeDocumentChanges(doc);
        if (changeResult) {
          results.push(changeResult);
        }
      } catch (error) {
        console.error(`Failed to analyze changes for ${doc.id}:`, error);
      }
    }

    return results;
  }

  private async performAdvancedChangeDetection(documents: RegulatoryDocument[]): Promise<ChangeDetectionResult[]> {
    const results: ChangeDetectionResult[] = [];

    for (const doc of documents) {
      const changeResult = await this.performDeepChangeAnalysis(doc);
      if (changeResult) {
        results.push(changeResult);
      }
    }

    return results;
  }

  private async analyzeDocumentChanges(document: RegulatoryDocument): Promise<ChangeDetectionResult | null> {
    // Get document history
    const history = this.documentHistory.get(document.id) || [];
    
    if (history.length === 0) {
      // New document
      return {
        documentId: document.id,
        changeType: 'new',
        changedSections: [],
        severity: document.impactLevel,
        confidence: 100,
        automatedAnalysis: `New regulatory document: ${document.title}`,
        requiresHumanReview: document.impactLevel === 'critical'
      };
    }

    const previousVersion = history[history.length - 1];
    
    // Compare content hashes
    if (previousVersion.currentVersionHash === document.currentVersionHash) {
      return null; // No changes
    }

    // Analyze what changed
    const changedSections = await this.identifyChangedSections(previousVersion, document);
    const severity = this.assessChangeSeverity(changedSections, document);
    const confidence = this.calculateChangeConfidence(changedSections);

    return {
      documentId: document.id,
      changeType: 'modified',
      changedSections,
      severity,
      confidence,
      automatedAnalysis: await this.generateChangeAnalysis(changedSections, document),
      requiresHumanReview: severity === 'critical' || confidence < 80
    };
  }

  private async performDeepChangeAnalysis(document: RegulatoryDocument): Promise<ChangeDetectionResult | null> {
    // Enhanced analysis with section-by-section comparison
    const history = this.documentHistory.get(document.id) || [];
    
    if (history.length === 0) {
      return await this.analyzeDocumentChanges(document);
    }

    const previousVersion = history[history.length - 1];
    
    // Perform semantic analysis of changes
    const semanticChanges = await this.performSemanticAnalysis(previousVersion, document);
    const legalImpactAnalysis = await this.analyzeLegalImpact(document);
    const businessImpactAssessment = await this.assessBusinessImpact(document);

    const changedSections = await this.identifyChangedSections(previousVersion, document);
    
    return {
      documentId: document.id,
      changeType: 'modified',
      changedSections,
      severity: document.impactLevel,
      confidence: this.calculateAdvancedConfidence(semanticChanges, legalImpactAnalysis),
      automatedAnalysis: await this.generateAdvancedAnalysis(document, semanticChanges, businessImpactAssessment),
      requiresHumanReview: document.impactLevel === 'critical' || semanticChanges.requiresExpertReview
    };
  }

  private async identifyChangedSections(previous: RegulatoryDocument, current: RegulatoryDocument): Promise<ChangedSection[]> {
    const sections: ChangedSection[] = [];
    
    // Compare key fields
    if (previous.title !== current.title) {
      sections.push({
        sectionName: 'title',
        previousContent: previous.title,
        newContent: current.title,
        changeType: 'modification',
        impactAssessment: 'Document title changed - may indicate significant regulatory shift'
      });
    }

    if (previous.status !== current.status) {
      sections.push({
        sectionName: 'status',
        previousContent: previous.status,
        newContent: current.status,
        changeType: 'modification',
        impactAssessment: 'Legal status changed - immediate compliance review required'
      });
    }

    if (previous.effectiveDate?.getTime() !== current.effectiveDate?.getTime()) {
      sections.push({
        sectionName: 'effective_date',
        previousContent: previous.effectiveDate?.toISOString() || '',
        newContent: current.effectiveDate?.toISOString() || '',
        changeType: 'modification',
        impactAssessment: 'Implementation timeline changed - update compliance calendar'
      });
    }

    // Compare content using diff algorithm
    if (previous.content !== current.content) {
      const contentDiff = await this.generateContentDiff(previous.content || '', current.content || '');
      sections.push({
        sectionName: 'content',
        previousContent: previous.content || '',
        newContent: current.content || '',
        changeType: 'modification',
        impactAssessment: contentDiff
      });
    }

    return sections;
  }

  private async generateContentDiff(previousContent: string, newContent: string): Promise<string> {
    // Simple diff implementation - in production would use proper diff algorithm
    const previousLines = previousContent.split('\n');
    const newLines = newContent.split('\n');
    
    let changes = 0;
    const maxLines = Math.max(previousLines.length, newLines.length);
    
    for (let i = 0; i < maxLines; i++) {
      if (previousLines[i] !== newLines[i]) {
        changes++;
      }
    }
    
    const changePercentage = (changes / maxLines) * 100;
    
    if (changePercentage > 50) {
      return 'Major content revision - comprehensive review required';
    } else if (changePercentage > 20) {
      return 'Significant content changes - detailed analysis needed';
    } else if (changePercentage > 5) {
      return 'Minor content updates - review recommended';
    } else {
      return 'Minimal content changes - low priority review';
    }
  }

  private assessChangeSeverity(changedSections: ChangedSection[], document: RegulatoryDocument): 'critical' | 'high' | 'medium' | 'low' {
    // Critical changes
    const hasCriticalSections = changedSections.some(section => 
      section.sectionName === 'status' || 
      section.sectionName === 'effective_date' ||
      section.impactAssessment.includes('immediate') ||
      section.impactAssessment.includes('required')
    );

    if (hasCriticalSections || document.impactLevel === 'critical') {
      return 'critical';
    }

    // High impact changes
    if (changedSections.length > 3 || document.impactLevel === 'high') {
      return 'high';
    }

    // Medium impact
    if (changedSections.length > 1 || document.impactLevel === 'medium') {
      return 'medium';
    }

    return 'low';
  }

  private calculateChangeConfidence(changedSections: ChangedSection[]): number {
    let confidence = 100;
    
    // Reduce confidence for unclear changes
    changedSections.forEach(section => {
      if (section.impactAssessment.includes('review')) {
        confidence -= 10;
      }
      if (section.changeType === 'modification' && section.newContent.length < 50) {
        confidence -= 5;
      }
    });

    return Math.max(confidence, 50); // Minimum 50% confidence
  }

  private async generateChangeAnalysis(changedSections: ChangedSection[], document: RegulatoryDocument): Promise<string> {
    const analysis = [];
    analysis.push(`Analysis for ${document.title}:`);
    analysis.push(`Document Impact Level: ${document.impactLevel.toUpperCase()}`);
    analysis.push(`Changes Detected: ${changedSections.length} sections modified`);
    
    changedSections.forEach(section => {
      analysis.push(`‚Ä¢ ${section.sectionName}: ${section.impactAssessment}`);
    });

    if (document.keyChanges.length > 0) {
      analysis.push('Key Changes:');
      document.keyChanges.forEach(change => analysis.push(`‚Ä¢ ${change}`));
    }

    return analysis.join('\n');
  }

  // ===== INTELLIGENT ALERT GENERATION =====

  private async generateIntelligentAlerts(documents: RegulatoryDocument[], changes: ChangeDetectionResult[]): Promise<RegulatoryAlert[]> {
    const alerts: RegulatoryAlert[] = [];
    
    // Process all documents for potential alerts
    for (const doc of documents) {
      const relatedChanges = changes.filter(change => change.documentId === doc.id);
      
      if (this.shouldGenerateAlert(doc, relatedChanges)) {
        const alert = await this.createIntelligentAlert(doc, relatedChanges);
        alerts.push(alert);
      }
    }

    // Generate industry impact alerts
    const industryAlerts = await this.generateIndustryImpactAlerts(documents);
    alerts.push(...industryAlerts);

    // Generate compliance deadline alerts
    const deadlineAlerts = await this.generateComplianceDeadlineAlerts(documents);
    alerts.push(...deadlineAlerts);

    return alerts;
  }

  private async generateRealTimeAlerts(documents: RegulatoryDocument[], changes: ChangeDetectionResult[]): Promise<RegulatoryAlert[]> {
    const alerts: RegulatoryAlert[] = [];
    
    // Only generate alerts for high-priority changes
    for (const doc of documents) {
      if (doc.impactLevel === 'critical' || doc.changeDetected) {
        const relatedChanges = changes.filter(change => change.documentId === doc.id);
        const alert = await this.createUrgentAlert(doc, relatedChanges);
        alerts.push(alert);
      }
    }

    return alerts;
  }

  private shouldGenerateAlert(document: RegulatoryDocument, changes: ChangeDetectionResult[]): boolean {
    // Always alert for critical documents
    if (document.impactLevel === 'critical') return true;
    
    // Alert for any detected changes with high confidence
    if (changes.some(change => change.confidence > 90 && change.severity !== 'low')) return true;
    
    // Alert for documents with approaching deadlines
    if (document.complianceDeadline) {
      const daysUntilDeadline = Math.floor(
        (document.complianceDeadline.getTime() - Date.now()) / (1000 * 60 * 60 * 24)
      );
      if (daysUntilDeadline <= 30) return true;
    }

    // Alert for documents in filtered industries
    if (this.config.industryFilters.length > 0) {
      return document.industries.some(industry => this.config.industryFilters.includes(industry));
    }

    return document.impactLevel === 'high';
  }

  private async createIntelligentAlert(document: RegulatoryDocument, changes: ChangeDetectionResult[]): Promise<RegulatoryAlert> {
    const alertType = this.determineAlertType(document, changes);
    const severity = this.mapImpactToSeverity(document.impactLevel);
    
    return {
      id: crypto.randomUUID(),
      documentId: document.id,
      alertType,
      severity,
      title: await this.generateSmartAlertTitle(document, alertType, changes),
      description: await this.generateSmartAlertDescription(document, changes),
      affectedIndustries: document.industries,
      actionRequired: this.determineActionRequired(document, changes),
      deadline: document.complianceDeadline,
      recommendations: await this.generateContextualRecommendations(document, changes),
      createdAt: new Date(),
      notificationsSent: false
    };
  }

  private async createUrgentAlert(document: RegulatoryDocument, changes: ChangeDetectionResult[]): Promise<RegulatoryAlert> {
    return {
      id: crypto.randomUUID(),
      documentId: document.id,
      alertType: 'new_regulation',
      severity: 'critical',
      title: `üö® Í∏¥Í∏â: ${document.title}`,
      description: `Ï§ëÎåÄÌïú Í∑úÏ†ú Î≥ÄÍ≤ΩÏù¥ Í∞êÏßÄÎêòÏóàÏäµÎãàÎã§.\n\n${document.summary}\n\nÏ¶âÏãú Í≤ÄÌÜ†Í∞Ä ÌïÑÏöîÌï©ÎãàÎã§.`,
      affectedIndustries: document.industries,
      actionRequired: true,
      deadline: document.complianceDeadline,
      recommendations: [
        'Ï¶âÏãú Î≤ïÎ¨¥ÌåÄ ÎòêÎäî Ïª¥ÌîåÎùºÏù¥Ïñ∏Ïä§ Îã¥ÎãπÏûêÏóêÍ≤å ÏïåÎ¶º',
        'ÌòÑÏû¨ Ïö¥ÏòÅÏóê ÎØ∏ÏπòÎäî ÏòÅÌñ• Í∏¥Í∏â ÌèâÍ∞Ä',
        'ÌïÑÏöîÏãú Ï†ÑÎ¨∏Í∞Ä ÏÉÅÎã¥ ÏßÑÌñâ',
        'Í¥ÄÎ†® Ïù¥Ìï¥Í¥ÄÍ≥ÑÏûêÏóêÍ≤å ÏÉÅÌô© Í≥µÏú†'
      ],
      createdAt: new Date(),
      notificationsSent: false
    };
  }

  private determineAlertType(document: RegulatoryDocument, changes: ChangeDetectionResult[]): AlertType {
    if (changes.some(change => change.changeType === 'new')) {
      return 'new_regulation';
    }
    
    if (changes.some(change => change.changeType === 'modified')) {
      return 'regulation_change';
    }

    if (document.complianceDeadline) {
      const daysUntilDeadline = Math.floor(
        (document.complianceDeadline.getTime() - Date.now()) / (1000 * 60 * 60 * 24)
      );
      if (daysUntilDeadline <= 30) {
        return 'deadline_approaching';
      }
    }

    return 'compliance_update';
  }

  private async generateSmartAlertTitle(document: RegulatoryDocument, alertType: AlertType, changes: ChangeDetectionResult[]): Promise<string> {
    const alertTypeNames = {
      'new_regulation': 'Ïã†Í∑ú Í∑úÏ†ú',
      'regulation_change': 'Í∑úÏ†ú Î≥ÄÍ≤Ω',
      'deadline_approaching': 'ÎßàÍ∞êÏùº ÏûÑÎ∞ï',
      'compliance_update': 'Ïª¥ÌîåÎùºÏù¥Ïñ∏Ïä§ ÏóÖÎç∞Ïù¥Ìä∏',
      'industry_impact': 'ÏóÖÍ≥Ñ ÏòÅÌñ•',
      'penalty_change': 'Ï≤òÎ≤å Í∏∞Ï§Ä Î≥ÄÍ≤Ω'
    };

    const severityEmoji = {
      'critical': 'üö®',
      'high': '‚ö°',
      'medium': 'üìã',
      'low': '‚ÑπÔ∏è'
    };

    const severity = this.mapImpactToSeverity(document.impactLevel);
    const emoji = severityEmoji[severity];
    const typeName = alertTypeNames[alertType];

    return `${emoji} [${typeName}] ${document.title}`;
  }

  private async generateSmartAlertDescription(document: RegulatoryDocument, changes: ChangeDetectionResult[]): Promise<string> {
    const description = [];
    
    description.push(document.summary || document.title);
    description.push('');

    if (changes.length > 0) {
      description.push('üîÑ Ï£ºÏöî Î≥ÄÍ≤ΩÏÇ¨Ìï≠:');
      changes.forEach(change => {
        description.push(`‚Ä¢ ${change.automatedAnalysis}`);
      });
      description.push('');
    }

    if (document.keyChanges.length > 0) {
      description.push('üìã ÌïµÏã¨ Î≥ÄÌôî:');
      document.keyChanges.slice(0, 3).forEach(change => {
        description.push(`‚Ä¢ ${change}`);
      });
      description.push('');
    }

    if (document.complianceDeadline) {
      const deadline = document.complianceDeadline.toLocaleDateString('ko-KR');
      description.push(`‚è∞ Ï§ÄÏàò ÎßàÍ∞êÏùº: ${deadline}`);
    }

    return description.join('\n');
  }

  private async generateContextualRecommendations(document: RegulatoryDocument, changes: ChangeDetectionResult[]): Promise<string[]> {
    const recommendations: string[] = [];

    // Based on document impact level
    if (document.impactLevel === 'critical') {
      recommendations.push('Ï¶âÏãú Í≤ΩÏòÅÏßÑÏóêÍ≤å Î≥¥Í≥† Î∞è Í∏¥Í∏â ÎåÄÏùëÌåÄ Íµ¨ÏÑ±');
      recommendations.push('ÌòÑÏû¨ ÏÇ¨ÏóÖ Ïö¥ÏòÅÏóê ÎØ∏ÏπòÎäî Ï¶âÍ∞ÅÏ†Å ÏòÅÌñ• Î∂ÑÏÑù');
      recommendations.push('Ï†ÑÎ¨∏ Î≤ïÎ•† ÏûêÎ¨∏ÏùÑ ÌÜµÌïú ÎåÄÏùë Ï†ÑÎûµ ÏàòÎ¶Ω');
    } else if (document.impactLevel === 'high') {
      recommendations.push('Îã¥Îãπ Î∂ÄÏÑúÎ≥Ñ ÏòÅÌñ• Î∂ÑÏÑù Î∞è ÎåÄÏùë Í≥ÑÌöç ÏàòÎ¶Ω');
      recommendations.push('Í¥ÄÎ†® ÌåÄÍ≥ºÏùò ÌòëÏùòÎ•º ÌÜµÌïú Íµ¨Ï≤¥Ï†Å Ïã§Ìñâ Î∞©Ïïà ÎÖºÏùò');
    }

    // Based on change types
    const hasContentChanges = changes.some(change => 
      change.changedSections.some(section => section.sectionName === 'content')
    );
    
    if (hasContentChanges) {
      recommendations.push('Î≥ÄÍ≤ΩÎêú ÎÇ¥Ïö©Ïóê ÎåÄÌïú ÏÉÅÏÑ∏Ìïú Ï°∞Ìï≠Î≥Ñ Î∂ÑÏÑù Ïã§Ïãú');
      recommendations.push('Í∏∞Ï°¥ Ï†ïÏ±Ö Î∞è ÌîÑÎ°úÏÑ∏Ïä§ÏôÄÏùò Ï†ïÌï©ÏÑ± Í≤ÄÌÜ†');
    }

    // Based on compliance deadline
    if (document.complianceDeadline) {
      const daysRemaining = Math.floor(
        (document.complianceDeadline.getTime() - Date.now()) / (1000 * 60 * 60 * 24)
      );

      if (daysRemaining <= 7) {
        recommendations.push('Í∏¥Í∏â ÌÉúÏä§ÌÅ¨Ìè¨Ïä§ Íµ¨ÏÑ± Î∞è 24ÏãúÍ∞Ñ ÎåÄÏùë Ï≤¥Í≥Ñ Í∞ÄÎèô');
      } else if (daysRemaining <= 30) {
        recommendations.push('Ï£ºÍ∞Ñ ÏßÑÌñâÏÉÅÌô© Î™®ÎãàÌÑ∞ÎßÅ Î∞è Îã®Í≥ÑÎ≥Ñ Ïã§Ìñâ Í≥ÑÌöç ÏàòÎ¶Ω');
      } else {
        recommendations.push('Î∂ÑÍ∏∞Î≥Ñ Ï§ÄÎπÑ ÌòÑÌô© Ï†êÍ≤Ä Î∞è ÌïÑÏöî ÏûêÏõê ÌôïÎ≥¥');
      }
    }

    // Industry-specific recommendations
    if (document.industries.includes('fintech')) {
      recommendations.push('Í∏àÏúµÎãπÍµ≠ Í∞ÄÏù¥ÎìúÎùºÏù∏Í≥ºÏùò Ï†ïÌï©ÏÑ± Í≤ÄÌÜ†');
      recommendations.push('Í∏àÏúµÎ≥¥ÏïàÏõê Îì± Í¥ÄÎ†® Í∏∞Í¥ÄÍ≥ºÏùò ÏÇ¨Ï†Ñ ÌòëÏùò');
    }

    // Generic recommendations
    recommendations.push('Í¥ÄÎ†® Î∂ÄÏÑú ÏßÅÏõê ÎåÄÏÉÅ ÍµêÏú° Î∞è Ïù∏Ïãù Ï†úÍ≥†');
    recommendations.push('Í≥†Í∞ù Î∞è ÌååÌä∏ÎÑàÏÇ¨ ÎåÄÏÉÅ Î≥ÄÍ≤ΩÏÇ¨Ìï≠ ÏÇ¨Ï†Ñ ÏïàÎÇ¥');

    return recommendations;
  }

  // ===== NOTIFICATION AND ALERT PROCESSING =====

  private async processAlertNotifications(alerts: RegulatoryAlert[]): Promise<void> {
    if (!this.config.enableEmailNotifications) {
      console.log('üìß Email notifications disabled');
      return;
    }

    const criticalAlerts = alerts.filter(alert => alert.severity === 'critical');
    const highPriorityAlerts = alerts.filter(alert => alert.severity === 'high');

    console.log(`üì¨ Processing ${criticalAlerts.length} critical and ${highPriorityAlerts.length} high priority alerts`);

    // Send critical alerts immediately
    for (const alert of criticalAlerts) {
      await this.sendCriticalAlert(alert);
      alert.notificationsSent = true;
    }

    // Batch send high priority alerts
    if (highPriorityAlerts.length > 0) {
      await this.sendBatchAlerts(highPriorityAlerts);
      highPriorityAlerts.forEach(alert => alert.notificationsSent = true);
    }

    // Store alerts for future reference
    await this.storeAlertHistory(alerts);
  }

  private async processUrgentAlerts(alerts: RegulatoryAlert[]): Promise<void> {
    console.log(`üö® Processing ${alerts.length} urgent alerts`);

    for (const alert of alerts) {
      await this.sendCriticalAlert(alert);
      
      // Also send to Slack if enabled
      if (this.config.enableSlackIntegration) {
        await this.sendSlackAlert(alert);
      }

      alert.notificationsSent = true;
    }

    await this.storeAlertHistory(alerts);
  }

  private async sendCriticalAlert(alert: RegulatoryAlert): Promise<void> {
    try {
      // Convert to format expected by email service
      const emailAlert = {
        title: alert.title,
        summary: alert.description,
        importance: alert.severity,
        sourceName: 'Í∑úÏ†ú Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏä§ÌÖú',
        affectedIndustries: alert.affectedIndustries,
        publishedDate: alert.createdAt.toISOString(),
        businessImpact: alert.severity.toUpperCase()
      };

      // Send to all relevant users based on industry filters
      await emailNotificationService.notifyAllUsers(emailAlert, [alert.severity]);
      
      console.log(`‚úÖ Critical alert sent: ${alert.title}`);
    } catch (error) {
      console.error(`‚ùå Failed to send critical alert:`, error);
      this.logError('critical_alert', error as string);
    }
  }

  private async sendBatchAlerts(alerts: RegulatoryAlert[]): Promise<void> {
    // Group alerts by industry for targeted sending
    const alertsByIndustry = new Map<string, RegulatoryAlert[]>();
    
    alerts.forEach(alert => {
      alert.affectedIndustries.forEach(industry => {
        const industryAlerts = alertsByIndustry.get(industry) || [];
        industryAlerts.push(alert);
        alertsByIndustry.set(industry, industryAlerts);
      });
    });

    // Send batch notifications per industry
    for (const [industry, industryAlerts] of alertsByIndustry) {
      try {
        await this.sendIndustryBatchAlert(industry, industryAlerts);
        console.log(`‚úÖ Batch alert sent to ${industry}: ${industryAlerts.length} alerts`);
      } catch (error) {
        console.error(`‚ùå Failed to send batch alert to ${industry}:`, error);
        this.logError('batch_alert', error as string);
      }
    }
  }

  private async sendIndustryBatchAlert(industry: string, alerts: RegulatoryAlert[]): Promise<void> {
    const batchAlert = {
      title: `${industry} ÏóÖÍ≥Ñ Í∑úÏ†ú ÏóÖÎç∞Ïù¥Ìä∏ ${alerts.length}Í±¥`,
      summary: `${industry} ÏóÖÍ≥Ñ Í¥ÄÎ†® Ï£ºÏöî Í∑úÏ†ú Î≥ÄÍ≤ΩÏÇ¨Ìï≠ÏùÑ ÏïàÎÇ¥ÎìúÎ¶ΩÎãàÎã§.`,
      importance: 'high' as const,
      sourceName: 'Í∑úÏ†ú Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏä§ÌÖú',
      affectedIndustries: [industry],
      publishedDate: new Date().toISOString(),
      businessImpact: 'HIGH',
      alerts: alerts.map(alert => ({
        title: alert.title,
        description: alert.description,
        severity: alert.severity
      }))
    };

    await emailNotificationService.notifyAllUsers(batchAlert, ['high']);
  }

  private async sendSlackAlert(alert: RegulatoryAlert): Promise<void> {
    // Placeholder for Slack integration
    console.log(`üì± Slack alert: ${alert.title}`);
    // In production, implement actual Slack webhook integration
  }

  // ===== INDUSTRY IMPACT AND COMPLIANCE ANALYSIS =====

  private async generateIndustryImpactAlerts(documents: RegulatoryDocument[]): Promise<RegulatoryAlert[]> {
    const alerts: RegulatoryAlert[] = [];
    const industryImpacts = await this.analyzeIndustryImpacts(documents);

    for (const impact of industryImpacts) {
      if (impact.impactScore > 70) { // High impact threshold
        const alert = await this.createIndustryImpactAlert(impact);
        alerts.push(alert);
      }
    }

    return alerts;
  }

  private async generateComplianceDeadlineAlerts(documents: RegulatoryDocument[]): Promise<RegulatoryAlert[]> {
    const alerts: RegulatoryAlert[] = [];
    const deadlines = this.extractComplianceDeadlines(documents);

    for (const deadline of deadlines) {
      if (deadline.daysRemaining <= 30) {
        const alert = await this.createDeadlineAlert(deadline);
        alerts.push(alert);
      }
    }

    return alerts;
  }

  private async analyzeIndustryImpacts(documents: RegulatoryDocument[]): Promise<IndustryImpactAnalysis[]> {
    const industryGroups = new Map<string, RegulatoryDocument[]>();
    
    // Group documents by industry
    documents.forEach(doc => {
      doc.industries.forEach(industry => {
        const industryDocs = industryGroups.get(industry) || [];
        industryDocs.push(doc);
        industryGroups.set(industry, industryDocs);
      });
    });

    const impactAnalyses: IndustryImpactAnalysis[] = [];

    // Analyze impact for each industry
    for (const [industry, industryDocs] of industryGroups) {
      const analysis = await this.calculateIndustryImpact(industry, industryDocs);
      impactAnalyses.push(analysis);
    }

    return impactAnalyses;
  }

  private async calculateIndustryImpact(industry: string, documents: RegulatoryDocument[]): Promise<IndustryImpactAnalysis> {
    const criticalCount = documents.filter(doc => doc.impactLevel === 'critical').length;
    const highCount = documents.filter(doc => doc.impactLevel === 'high').length;
    const recentChanges = documents.filter(doc => doc.changeDetected).length;

    // Calculate impact score (0-100)
    let impactScore = 0;
    impactScore += criticalCount * 25; // Critical documents heavily weighted
    impactScore += highCount * 15;    // High impact documents
    impactScore += recentChanges * 10; // Recent changes
    impactScore += documents.length * 2; // Overall regulatory activity

    // Cap at 100
    impactScore = Math.min(impactScore, 100);

    // Determine risk level
    let riskLevel: IndustryImpactAnalysis['riskLevel'] = 'low';
    if (impactScore >= 80) riskLevel = 'very_high';
    else if (impactScore >= 60) riskLevel = 'high';
    else if (impactScore >= 40) riskLevel = 'medium';
    else if (impactScore >= 20) riskLevel = 'low';
    else riskLevel = 'very_low';

    return {
      industry,
      impactScore,
      affectedDocuments: documents.map(doc => doc.id),
      keyRegulations: documents.filter(doc => doc.impactLevel === 'critical' || doc.impactLevel === 'high'),
      riskLevel,
      opportunityAreas: await this.identifyOpportunities(industry, documents),
      complianceGaps: await this.identifyComplianceGaps(documents),
      recommendations: await this.generateIndustryRecommendations(industry, documents, impactScore)
    };
  }

  private extractComplianceDeadlines(documents: RegulatoryDocument[]): ComplianceDeadline[] {
    const deadlines: ComplianceDeadline[] = [];

    documents.forEach(doc => {
      if (doc.complianceDeadline) {
        const daysRemaining = Math.floor(
          (doc.complianceDeadline.getTime() - Date.now()) / (1000 * 60 * 60 * 24)
        );

        let severity: ComplianceDeadline['severity'] = 'low';
        if (daysRemaining <= 7) severity = 'critical';
        else if (daysRemaining <= 14) severity = 'high';
        else if (daysRemaining <= 30) severity = 'medium';

        deadlines.push({
          documentId: doc.id,
          title: doc.title,
          deadline: doc.complianceDeadline,
          daysRemaining,
          severity,
          affectedIndustries: doc.industries,
          requirements: this.extractRequirements(doc),
          penalties: doc.penalties ? [doc.penalties] : [],
          actionItems: this.generateDeadlineActionItems(doc, daysRemaining)
        });
      }
    });

    return deadlines.sort((a, b) => a.daysRemaining - b.daysRemaining);
  }

  // ===== UTILITY AND HELPER METHODS =====

  private async getActiveSourceCount(): Promise<number> {
    const sources = await koreanGovAPIs.getActiveSources();
    return sources.length;
  }

  private updateMonitoringStats(documents: RegulatoryDocument[], alerts: RegulatoryAlert[], processingTime: number): void {
    this.monitoringStats.totalDocumentsProcessed += documents.length;
    this.monitoringStats.alertsGenerated24h = alerts.length;
    this.monitoringStats.criticalAlerts24h = alerts.filter(a => a.severity === 'critical').length;
    this.monitoringStats.sourcesMonitored = documents.map(d => d.sourceId).filter((v, i, a) => a.indexOf(v) === i).length;
    this.monitoringStats.lastSuccessfulCheck = new Date();
    this.monitoringStats.averageProcessingTime = processingTime;
  }

  private updateIncrementalStats(documents: RegulatoryDocument[], alerts: RegulatoryAlert[], processingTime: number): void {
    this.monitoringStats.totalDocumentsProcessed += documents.length;
    this.monitoringStats.averageProcessingTime = (this.monitoringStats.averageProcessingTime + processingTime) / 2;
    this.monitoringStats.lastSuccessfulCheck = new Date();
  }

  private async storeDocumentHistory(documents: RegulatoryDocument[]): Promise<void> {
    documents.forEach(doc => {
      const history = this.documentHistory.get(doc.id) || [];
      history.push(doc);
      
      // Keep only last 10 versions
      if (history.length > 10) {
        history.shift();
      }
      
      this.documentHistory.set(doc.id, history);
    });
  }

  private async storeAlertHistory(alerts: RegulatoryAlert[]): Promise<void> {
    const today = new Date().toISOString().split('T')[0];
    const todayAlerts = this.alertHistory.get(today) || [];
    todayAlerts.push(...alerts);
    this.alertHistory.set(today, todayAlerts);
  }

  private logError(context: string, error: string): void {
    this.errorLog.push({
      timestamp: new Date(),
      error,
      source: context
    });

    // Keep only last 100 errors
    if (this.errorLog.length > 100) {
      this.errorLog.shift();
    }

    // Update error rate
    const recentErrors = this.errorLog.filter(log => 
      Date.now() - log.timestamp.getTime() < 24 * 60 * 60 * 1000
    );
    this.monitoringStats.errorRate = (recentErrors.length / Math.max(this.monitoringStats.totalDocumentsProcessed, 1)) * 100;
  }

  private mapImpactToSeverity(impact: string): 'critical' | 'high' | 'medium' | 'low' {
    return impact as 'critical' | 'high' | 'medium' | 'low';
  }

  private determineActionRequired(document: RegulatoryDocument, changes: ChangeDetectionResult[]): boolean {
    return document.impactLevel === 'critical' || 
           document.impactLevel === 'high' ||
           changes.some(change => change.severity === 'critical') ||
           !!document.complianceDeadline;
  }

  // Placeholder methods for advanced features
  private async performSemanticAnalysis(previous: RegulatoryDocument, current: RegulatoryDocument): Promise<any> {
    return { requiresExpertReview: current.impactLevel === 'critical' };
  }

  private async analyzeLegalImpact(document: RegulatoryDocument): Promise<any> {
    return { score: 85 };
  }

  private async assessBusinessImpact(document: RegulatoryDocument): Promise<any> {
    return { score: 75 };
  }

  private calculateAdvancedConfidence(semanticChanges: any, legalImpact: any): number {
    return Math.min((semanticChanges.score || 80) + (legalImpact.score || 80)) / 2;
  }

  private async generateAdvancedAnalysis(document: RegulatoryDocument, semanticChanges: any, businessImpact: any): Promise<string> {
    return `Advanced analysis for ${document.title}: Legal impact score ${businessImpact.score}/100`;
  }

  private async createIndustryImpactAlert(impact: IndustryImpactAnalysis): Promise<RegulatoryAlert> {
    return {
      id: crypto.randomUUID(),
      documentId: 'industry-impact',
      alertType: 'industry_impact',
      severity: impact.riskLevel === 'very_high' || impact.riskLevel === 'high' ? 'high' : 'medium',
      title: `${impact.industry} ÏóÖÍ≥Ñ Í∑úÏ†ú ÏòÅÌñ•ÎèÑ ${impact.impactScore}/100`,
      description: `${impact.industry} ÏóÖÍ≥ÑÏóê ÏòÅÌñ•ÏùÑ ÎØ∏ÏπòÎäî ${impact.keyRegulations.length}Í±¥Ïùò Ï£ºÏöî Í∑úÏ†ú Î≥ÄÌôîÍ∞Ä Í∞êÏßÄÎêòÏóàÏäµÎãàÎã§.`,
      affectedIndustries: [impact.industry],
      actionRequired: impact.riskLevel === 'very_high' || impact.riskLevel === 'high',
      recommendations: impact.recommendations,
      createdAt: new Date(),
      notificationsSent: false
    };
  }

  private async createDeadlineAlert(deadline: ComplianceDeadline): Promise<RegulatoryAlert> {
    return {
      id: crypto.randomUUID(),
      documentId: deadline.documentId,
      alertType: 'deadline_approaching',
      severity: deadline.severity,
      title: `‚è∞ ÎßàÍ∞êÏùº ${deadline.daysRemaining}Ïùº Ï†Ñ: ${deadline.title}`,
      description: `Ïª¥ÌîåÎùºÏù¥Ïñ∏Ïä§ ÎßàÍ∞êÏùºÏù¥ ${deadline.daysRemaining}Ïùº ÎÇ®ÏïòÏäµÎãàÎã§.\n\nÌïÑÏöîÌïú Ï°∞ÏπòÏÇ¨Ìï≠ÏùÑ ÌôïÏù∏ÌïòÍ≥† Ï§ÄÎπÑÌï¥Ï£ºÏÑ∏Ïöî.`,
      affectedIndustries: deadline.affectedIndustries,
      actionRequired: true,
      deadline: deadline.deadline,
      recommendations: deadline.actionItems,
      createdAt: new Date(),
      notificationsSent: false
    };
  }

  private async identifyOpportunities(industry: string, documents: RegulatoryDocument[]): Promise<string[]> {
    // Basic opportunity identification based on regulatory changes
    return [
      'ÏÉàÎ°úÏö¥ Í∑úÏ†úÏóê Îî∞Î•∏ Ïª®ÏÑ§ÌåÖ ÏÑúÎπÑÏä§ Í∏∞Ìöå',
      'Ïª¥ÌîåÎùºÏù¥Ïñ∏Ïä§ ÏÜîÎ£®ÏÖò Í∞úÎ∞ú Î∞è Ï†úÍ≥µ',
      'Í∑úÏ†ú Ï†ÅÏùëÏùÑ ÏúÑÌïú Í∏∞Ïà† ÌòÅÏã† Í∏∞Ìöå'
    ];
  }

  private async identifyComplianceGaps(documents: RegulatoryDocument[]): Promise<string[]> {
    return [
      'Ïã†Í∑ú Í∑úÏ†úÏóê ÎåÄÌïú ÎÇ¥Î∂Ä Ï†ïÏ±Ö ÎØ∏ÎπÑ',
      'Ïª¥ÌîåÎùºÏù¥Ïñ∏Ïä§ Ï≤¥ÌÅ¨ ÌîÑÎ°úÏÑ∏Ïä§ Î∂ÄÏ°±',
      'Í∑úÏ†ú Î≥ÄÌôîÏóê ÎåÄÌïú Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏä§ÌÖú Î∂ÄÏû¨'
    ];
  }

  private async generateIndustryRecommendations(industry: string, documents: RegulatoryDocument[], impactScore: number): Promise<string[]> {
    const recommendations = [
      `${industry} ÏóÖÍ≥Ñ ÌäπÌôî Ïª¥ÌîåÎùºÏù¥Ïñ∏Ïä§ ÌåÄ Íµ¨ÏÑ±`,
      'Í∑úÏ†ú Î≥ÄÌôî Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏä§ÌÖú ÎèÑÏûÖ',
      'Ï†ïÍ∏∞Ï†ÅÏù∏ Î¶¨Ïä§ÌÅ¨ Ïñ¥ÏÑ∏Ïä§Î®ºÌä∏ Ïã§Ïãú'
    ];

    if (impactScore > 70) {
      recommendations.unshift('Ï¶âÏãú Í≤ΩÏòÅÏßÑ Î≥¥Í≥† Î∞è ÎπÑÏÉÅ ÎåÄÏùëÌåÄ Í∞ÄÎèô');
    }

    return recommendations;
  }

  private extractRequirements(document: RegulatoryDocument): string[] {
    // Extract requirements from document content
    return document.keyChanges.filter(change => 
      change.includes('ÏùòÎ¨¥') || change.includes('ÌïÑÏàò') || change.includes('Ï§ÄÏàò')
    );
  }

  private generateDeadlineActionItems(document: RegulatoryDocument, daysRemaining: number): string[] {
    const items = [];

    if (daysRemaining <= 7) {
      items.push('Í∏¥Í∏â ÎåÄÏùëÌåÄ Íµ¨ÏÑ± Î∞è 24ÏãúÍ∞Ñ Î™®ÎãàÌÑ∞ÎßÅ');
      items.push('Î™®Îì† ÌïÑÏàò Î¨∏ÏÑú Î∞è Ï†àÏ∞® ÏµúÏ¢Ö Ï†êÍ≤Ä');
    } else if (daysRemaining <= 14) {
      items.push('ÌïÑÏàò Ï§ÄÎπÑÏÇ¨Ìï≠ Ï†êÍ≤Ä Î¶¨Ïä§Ìä∏ ÏûëÏÑ±');
      items.push('Í¥ÄÎ†® ÌåÄÎ≥Ñ Ïó≠Ìï† Î∂ÑÎã¥ Î∞è ÏùºÏ†ï ÌôïÏ†ï');
    } else {
      items.push('Ï§ÄÎπÑ ÌòÑÌô© Í≤ÄÌÜ† Î∞è Í≥ÑÌöç ÏàòÎ¶Ω');
      items.push('ÌïÑÏöî ÏûêÏõê Î∞è ÏòàÏÇ∞ ÌôïÎ≥¥');
    }

    return items;
  }

  // ===== PUBLIC API METHODS =====

  async getMonitoringStats(): Promise<MonitoringStats> {
    return { ...this.monitoringStats };
  }

  async updateConfiguration(newConfig: Partial<MonitoringConfiguration>): Promise<void> {
    this.config = { ...this.config, ...newConfig };
    console.log('‚úÖ Monitoring configuration updated');
  }

  async getConfiguration(): Promise<MonitoringConfiguration> {
    return { ...this.config };
  }

  async getRecentAlerts(hours: number = 24): Promise<RegulatoryAlert[]> {
    const cutoff = new Date();
    cutoff.setHours(cutoff.getHours() - hours);
    
    const recentAlerts: RegulatoryAlert[] = [];
    
    for (const alerts of this.alertHistory.values()) {
      recentAlerts.push(...alerts.filter(alert => alert.createdAt >= cutoff));
    }
    
    return recentAlerts.sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime());
  }

  async getCriticalAlerts(): Promise<RegulatoryAlert[]> {
    return await koreanGovAPIs.getCriticalAlerts();
  }

  async getIndustryImpact(industry: string): Promise<IndustryImpactAnalysis | null> {
    const documents = await koreanGovAPIs.getDocumentsByIndustry(industry);
    if (documents.length === 0) return null;
    
    return await this.calculateIndustryImpact(industry, documents);
  }

  async getComplianceDeadlines(days: number = 30): Promise<ComplianceDeadline[]> {
    const recentDocs = await koreanGovAPIs.getRecentChanges(days);
    return this.extractComplianceDeadlines(recentDocs);
  }

  async getHealthStatus(): Promise<{ status: string; details: any }> {
    const errors24h = this.errorLog.filter(log => 
      Date.now() - log.timestamp.getTime() < 24 * 60 * 60 * 1000
    ).length;

    const status = this.isMonitoring && errors24h < 10 ? 'healthy' : 'degraded';
    
    return {
      status,
      details: {
        monitoring: this.isMonitoring,
        errors24h,
        lastCheck: this.monitoringStats.lastSuccessfulCheck,
        sourcesActive: this.monitoringStats.sourcesMonitored,
        uptime: this.monitoringStats.uptime
      }
    };
  }
}

export const enhancedRegulatoryMonitor = new EnhancedRegulatoryMonitoringService();